---
title: "Problem 2"
jupyter: julia-1.10
---

## Problem Statement

Each new term in the Fibonacci sequence is generated by adding the previous two terms.
By starting with 1 and 2, the first 10 terms will be:

$$
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \dots
$$

By considering the terms in the Fibonacci sequence whose values do not exceed four
million, find the sum of the even-valued terms.

## Solution

The *Fibonacci sequence* is defined by the recurrence relation

$$
\begin{align}
F_0 &= 0\\
F_1 &= 1\\
F_n &= F_{n-1} + F_{n-2}, \quad \mathrm{for} \ n > 1.
\end{align}
$$ {#eq-fibonacci}

### Recursive Solution

Recurrence problems lend themself naturally to *recursion*, a computational technique
where a function calls itself.

Recursion consists usually of two steps

1.  **base case**: produces a trivial result and stops the computation
2.  **recursive case**: the functions calls itself with an ever increasing or
  decreasing parameter.

In order to avoid infinite loops, the recursive step must modify the input value in such
way that eventually the base case is reached.

A naive implementation could look like so:

```{julia}
#| output: false
fibonacci(n::Int) = (n <= 1) ? n : fibonacci(n-1) + fibonacci(n-2)
```

While this function will work and eventually produce the correct value, it shows a
very poor performance: it employs *multiple recursion* as it contains two self-references,
leading to exponential running time and space.
So, calling `fibonacci` with an input greater than 40 will probably run out of
stack space before finishing.

One way to avoid exponential growth is to use a technique called *memoization*:
the function checks whether the input value has been calculated previously.
If so, it is simply returned; if not, the value is calculated recursively,
stored and returned.

```{julia}
#| output: false
global cache = Dict{Int, Int}(0 => 0, 1 => 1)

function memoization(n::Int)
  get!(cache, n) do
    memoization(n-1) + memoization(n-2)
  end
end
```

Let's test that for $n = 40$:

```{julia}
memoization(40)
```

A nice side effect of this computation is that now we have a cache which contains all the
fibonacci numbers up to 40.

```{julia}
for (k, v) in pairs(cache)
  1 < k < 12 ? println("$k \t=> $v") : nothing
end
```

We can use the cache to finally create our first solution

```{julia}
#| output: false
recursive(n) = sum(x -> x <= n && x % 2 == 0 ? x : 0, values(cache))
```

and test it like so:

```{julia}
@assert recursive(100) == 44
```

### Iterative Solution

Another way to avoid exponential growth from multiple recursion is to convert it to
*corecursion* by passing both previous values ($n-1$ and $n-2$) to the function at once.

With a purely functional language like `Haskell` without a way to implement loops we
would stick to recursion and solve the problem with *corecursion* like so:

``` haskell
evenFibSum n = sum $ takeWhile (<= n) $ filter even $ fibSeq 1 2
  where fibSeq a b = a:fibSeq b (a+b)
```

This would be quite performant, as we are using only one *tail-recursive* call
(and a lazy infinite list).

But with an imperative language like `Julia` it's probably better to use *iteration*
instead of *recursion*, as it is not obvious at all whether the compiler could optimize
that tail-recursive call into a performant executable.
But nonetheless, we'll stick to the same idea, using two independent variables to
calculate the result:

```{julia}
#| output: false
function iterative(n)
  a, b = 1, 2
  s = 0
  while b <= n
    b % 2 == 0 ? s += b : nothing
    a, b = b, a+b
  end
  s
end
```

Observe that we're starting the sequence with 1 and 2, as postulated in the problem statement.

```{julia}
@assert iterative(100) == 44
@assert recursive(4_000_000) == iterative(4_000_000)
```

Which solution is more performant?

```{julia}
using BenchmarkTools
@btime recursive(4_000_000)
@btime iterative(4_000_000)
"ðŸ"
```

`iterative` is more than 10 times faster than `recursive`, but that's not due to
recursion beeing slower than iteration.\
Remember, the values for `recursive` were computed ahead of time and stored in the cache.
Looking at the benchmark results, we can see that `recursive` employs some memory
allocations, and that's due to the fact that the underlying dictionary is an object
located in the program's heap. Dealing with those references is obviously slower than
calculating solely in the program's stack.

But there's still room for improvement: we want to get rid of that check for even numbers.
If we look at the Fibonacci sequence again

$$
1, 1, \mathbf{2}, 3, 5, \mathbf{8}, 13, 21, \mathbf{34}, 55, 89, \mathbf{144}, \dots
$$

we can see that every third Fibonacci number *is* even.\
We'll use that fact to modify our function such that every third number is added to the
running sum:

```{julia}
#| output: false
function optimized(n)
  a, b = 1, 1
  c = a+b
  s = 0
  while c <= n
    s += c
    a = b+c
    b = c+a
    c = a+b
  end
  s
end
```

```{julia}
@assert optimized(4_000_000) == iterative(4_000_000)
@btime optimized(4_000_000)
"ðŸ"
```

That speeds up our function by a factor of 3.

## Fibonacci Numbers

The Fibonacci numbers are named after the Italian mathematician Leonardo of Pisa, also
known as Fibonacci, who introduced the sequence to Western European mathematics in his
1202 book *Liber Abaci*.

Fibonacci numbers appear unexpectedly often in mathematics, and have a wide variation of
applications.
They also appear in biological settings, such as branching in trees, the arrangement of
leaves on a stem, the fruit sprouts of a pineapple, the flowering of an artichoke, and the
arrangement of a pine cone's bracts, though they do not occur in all species.

![Fibonacci Spiral in a sunflower](fib_sunflower.jpg){fig-align="center"}

Fibonacci numbers are also strongly related to the golden ratio: Binet's formula expresses
the *n*th Fibonacci number in terms of *n* and the golden ratio, and implies that the ratio
of two consecutive Fibonacci numbers tends to the golden ratio as *n* increases.

We'll discover some of these applications in subsequent problems.

### History and Origin

The Fibonacci sequence appears in Indian mathematics, in connection with Sanskrit prosody.
Fibonacci rediscoverd the sequence and used it to calculate the growth of rabbit populations.
He considers the growth of an idealized (biologically unrealistic) rabbit population,
assuming that

* a newly born breeding pair of rabbits are put in a field
* each breeding pair mates at the age of one month
* at the end of their second month they always produce another pair of rabbits
* rabbits never die, but continue breeding forever.

![Fibonacci's rabbits^[<a href="https://commons.wikimedia.org/wiki/File:Fibonacci_Rabbits.svg">Romain</a>, <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0 Deed</a>]](https://upload.wikimedia.org/wikipedia/commons/a/af/Fibonacci_Rabbits.svg){align="center" width=400}

### Fibonacci Tiling and Spiral

The Fibonacci spiral is an approximation of the *golden spiral* created by drawing
circular arcs connecting the opposite corners of squares in the Fibonacci tiling
(see @fig-fibonacci).

```{julia}
#| code-fold: true
#| label: fig-fibonacci
#| fig-cap: "Fibonacci Tiling"
#| fig-align: center
using Luxor, Colors

u = 20

Drawing(34u, 21u, "fibonacci-tiling.svg")
origin(24u, 15u)
fibSeq = [1,1,2,3,5,8,13,21]
cls = distinguishable_colors(length(fibSeq), [RGB(1,1,1), RGB(0,0,0)], dropseed=true)
fontface("Arial")
fontsize(12)
setline(3)
for (i,v) in enumerate(fibSeq)
  setcolor(cls[i])
  rect(Point(0,0), v*u, v*u, action=:fill)
  sethue("gold")
  i%4 == 1 && carc2r(Point(v*u, 0), Point(0,0), Point(v*u, v*u), action=:stroke)
  i%4 == 2 && carc2r(Point(0, 0), Point(0, v*u), Point(v*u, 0), action=:stroke)
  i%4 == 3 && carc2r(Point(0, v*u), Point(v*u, v*u), Point(0, 0), action=:stroke)
  i%4 == 0 && carc2r(Point(v*u, v*u), Point(v*u, 0), Point(0, v*u), action=:stroke)
  sethue("white")
  text(string(v), Point(6,6), halign=:left, valign=:top)
  i == length(fibSeq) && break
  if i == 1
    translate(u, 0)
  elseif i == 2
    translate(-u, -2u)
  else
    i%4 == 1 && translate(v*u, -fibSeq[i-1]*u)
    i%4 == 2 && translate(-fibSeq[i-1]*u, -fibSeq[i+1]*u)
    i%4 == 3 && translate(-fibSeq[i+1]*u, 0)
    i%4 == 0 && translate(0, v*u)
  end
end
finish()
preview()
```
