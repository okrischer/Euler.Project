\documentclass[12pt]{article}
\usepackage{mathtools}
%include polycode.fmt
\title{Even Fibonacci Numbers}
\author{Oliver Krischer}
\begin{document}
\maketitle
\begin{code}
module Main where

import Criterion.Main

main = defaultMain [ 
  bgroup "sumFibMem"
      [ bench "4000000"     $ whnf sumFibMem 4000000
      , bench "1000000000"  $ whnf sumFibMem 1000000000 ],
  bgroup "sumFibIt"
      [ bench "4000000"     $ whnf sumFibIt 4000000
      , bench "1000000000"  $ whnf sumFibIt 1000000000 ],
  bgroup "sumFibImp"
      [ bench "4000000"     $ whnf sumFibImp 4000000
      , bench "1000000000"  $ whnf sumFibImp 1000000000 ]
  ]
\end{code}
\section{Problem}
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
\[1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \ldots \]
\textbf{By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms!}
\section{Solution}
\subsection{Recursive Implementation with Memoization}
This recursive implementation with memoization ist substancially faster then a naive recursive implementation, which would follow the mathematical rule: \[fib (n) = fib (n-1) + fib (n-2)\]
\begin{code}
fib :: Int -> [Int] -> [Int]
fib limit memo@(n1:n2:_) 
    | next > limit = memo
    | otherwise = fib limit (next:memo) 
    where next = n1 + n2

sumFibMem :: Int -> Int
sumFibMem limit = sum $ filter even $ fib limit [1,1]
\end{code}
\subsection{Iterative Implementation}
While the recursive implementation was based on working with lists, the following implementation mimics an iterative solution in which the values of $(a=n-2)$ and $(b=n-1)$ and the accumulated \emph{sum} are passed to the next recursive call:
\begin{code}
sumFib :: Int -> (Int, Int) -> Int -> Int
sumFib limit (a, b) sum 
  | c > limit = sum
  | otherwise = 
    if even c then sumFib limit (b, c) (sum + c)
    else sumFib limit (b, c) sum
  where c = a + b

sumFibIt limit = sumFib limit (1,1) 0
\end{code}
\subsection{Further Improving}
Looking at the Fibonacci sequence
\[1, 1, \textbf{2}, 3, 5, \textbf{8}, 13, 21, \textbf{34}, 55, 89, \textbf{144}, \ldots\]
we can easily see that every third Fibonacci number is even. If this holds true for all Fibonacci numbers, we can get rid of the test for |even| like this:
\begin{code}
sumFib' :: Int -> (Int, Int, Int) -> Int -> Int
sumFib' limit (a, b, c) sum 
  | c > limit = sum
  | otherwise = sumFib' limit (a', b', c') (sum + c)
  where 
    a' = c  + b
    b' = a' + c
    c' = a' + b'

sumFibImp limit = sumFib' limit (1,1,2) 0
\end{code}
\textbf{Proof of our claim, that every third Fibonacci number is even:}
Following the rule for Fibonacci numbers, that every next number is the sum of it's two predecessors or more rigourus 
\[fib (n) = fib (n-1) + fib (n-2), where fib\{0,1\} = 1\]
we get an |even| number if both preceeding numbers are \emph{odd}, and an |odd| number if only one of the predecessors is \emph{odd}.
Given the starting values of $fib(n)$ with $\{1,1\}$ (both \emph{odd}), we get |2| as the first successor, which is |even|. We now have a sequence of $\{1,1,2\}$, which is $\{odd, odd, even\}$.
Given this sequence of the first three Fibonacci numbers $\{a,b,c\}$, we can deduce that every following sequence of three numbers $\{a', b', c'\}$ must also be $\{odd, odd, even\}$: 
\[\{a,b,c\}=\{odd,odd,even\} \implies \{a',b',c'\}=\{odd,odd,even\}\]
\begin{align}
\{a',b',c'\}&=\{(c+b), (a'+c), (a'+b')\} \\
&=\{(even+odd), (a'+c), (a'+b')\} \\
&=\{odd, (odd+even), (a'+b')\} \\
&=\{odd, odd, (odd+odd)\} \\
&=\{odd, odd, even\}
\end{align}
This also proofs the correctness of our algorithm (look at (1) of the proof).
\subsection{Complexity Analysis}
A naive recursive solution would have a runtime complexity of at least $\mathcal{O}(n^2)$, depending on the actual implementation. The solutions |sumFibMem|, |sumFibIt| and |sumFibImp| all share a complexity of $\mathcal{O}(n)$, as they have to iterate through the natural numbers up to $n$. Nontheless, |sumFibIt| and |sumFibImp| are substancially faster, as they don't have to iterate through all numbers repectively an intermediate result list.
\end{document}