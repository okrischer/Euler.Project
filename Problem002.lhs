\chapter{Problem 002: Even Fibonacci Numbers}
Each new term in the Fibonacci sequence is generated by adding the previous two terms.
By starting with 1 and 2, the first 10 terms will be:

\begin{equation*}
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \ldots
\end{equation*}

\textbf{By considering the terms in the Fibonacci sequence whose values do not
exceed four million, find the sum of the even-valued terms.}

\begin{code}
{-# OPTIONS_GHC -Wno-incomplete-patterns #-}
import Criterion.Main
import Test.QuickCheck ( (==>), quickCheck, Property )
\end{code}

\section{Recursive Implementation with Memoization}

The following implementation with memoization ist substancially faster then a
naive recursive implementation, which would follow the mathematical rule:

\begin{equation*}
fib(n) = fib(n-1) + fib(n-2).
\end{equation*}

\begin{code}
fibMem :: Integer -> Integer
fibMem limit = sum $ filter even $ run limit [1,1]
    where run limit memo@(a:b:_)
            | next > limit = memo
            | otherwise = run limit (next:memo)
            where next = a + b
\end{code}

\section{Functional approach}

Using lazy list evaluation and higher order functions we can implement a more
idiomatic Haskell solution:

\begin{code}
fibFun :: Integer -> Integer
fibFun limit = sum $ takeWhile (<= limit) $ filter even $ fibs 1 2
    where fibs a b = a : fibs b (a + b)
\end{code}

From the benchmark we can see that \mintinline{haskell}{fibFun} is about twice as
fast as \mintinline{haskell}{fibMem}, both of them having linear runtime.

\section{Imperative Implementation}

While the recursive and functional implementations were based on working
with lists in Haskell, the following implementation gives an imperative solution in Julia:

\begin{jl}
function fibIter(limit)
  a = 0
  b = 1
  acc = 0
  while (a + b) <= limit
    next = a + b
    if iseven(next)
      acc += next
    end
    a, b = b, a+b
  end
  acc
end
\end{jl}

\section{Further Improving}

Looking at the Fibonacci sequence

\begin{equation*}
1, 1, \textbf{2}, 3, 5, \textbf{8}, 13, 21, \textbf{34}, 55, 89, \textbf{144}, \ldots
\end{equation*}

we can easily see that every third Fibonacci number is even.
Thus, we can get rid of the test for \mintinline{jl}{iseven()} like this:

\begin{jl}
function fibOpt(limit)
  a = 1
  b = 1
  c = 2
  acc = 0
  while c <= limit
    acc += c
    a = b + c
    b = a + c
    c = a + b
  end
  acc
end
\end{jl}

From the benchmark we can see that \mintinline{jl}{fibOpt} is about three times
faster than \mintinline{jl}{fibIter}, both of them having linear runtime.


\section{Testing}

\begin{code}
equalsMemFun :: Integer -> Property
equalsMemFun n = n > 10 ==> fibMem n == fibFun n

main = do
  quickCheck equalsMemFun
\end{code}

\section{Benchmark}

\begin{spec}
-- alternative main for benchmarking
main = defaultMain [
  bgroup "fib" [ bench "Mem"  $ whnf fibMem 4000000
               , bench "Fun"  $ whnf fibFun 4000000
               ]
  ]
\end{spec}


