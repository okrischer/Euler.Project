\chapter{Problem 002: Even Fibonacci Numbers}
Each new term in the Fibonacci sequence is generated by adding the previous two terms.
By starting with 1 and 2, the first 10 terms will be:

\begin{equation*}
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \ldots
\end{equation*}

\textbf{By considering the terms in the Fibonacci sequence whose values do not
exceed four million, find the sum of the even-valued terms.}

\begin{code}
{-# OPTIONS_GHC -Wno-incomplete-patterns #-}
import Criterion.Main
import Test.QuickCheck ( (==>), quickCheck, Property )
\end{code}

\section{Recursive Implementation with Memoization}

The following implementation with memoization ist substancially faster then a
naive recursive implementation, which would follow the mathematical rule:

\begin{equation*}
fib(n) = fib(n-1) + fib(n-2).
\end{equation*}

\begin{code}
fibMem :: Integer -> Integer
fibMem limit = sum $ filter even $ run limit [1,1]
    where run limit memo@(a:b:_)
            | next > limit = memo
            | otherwise = run limit (next:memo)
            where next = a + b
\end{code}

\section{Functional approach}

Using lazy list evaluation and higher order functions we can implement a more
idiomatic Haskell solution:

\begin{code}
fibFun :: Integer -> Integer
fibFun limit = sum $ takeWhile (<= limit) $ filter even $ fibs 1 2
    where fibs a b = a : fibs b (a + b)
\end{code}

From the benchmark we can see that \mintinline{haskell}{fibFun} is about twice as
fast as \mintinline{haskell}{fibMem}, both of them having linear runtime.

\section{Testing}

\begin{code}
equalsMemFun :: Integer -> Property
equalsMemFun n = n > 10 ==> fibMem n == fibFun n

main = do
  quickCheck equalsMemFun
\end{code}

\section{Benchmark}

\begin{spec}
-- alternative main for benchmarking
main = defaultMain [
  bgroup "fib" [ bench "Mem"  $ whnf fibMem 4000000
               , bench "Fun"  $ whnf fibFun 4000000
               ]
  ]
\end{spec}


